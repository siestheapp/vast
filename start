#!/usr/bin/env bash
set -euo pipefail

# Start VAST: ensure Docker + Postgres (pagila) on 5433, venv deps, then run app.

# Resolve script directory even when invoked via symlink
SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do
  DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ "$SOURCE" != /* ]] && SOURCE="$DIR/$SOURCE"
done
PROJECT_DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
cd "$PROJECT_DIR"

ENV_HASH=""
DB_USER=""
DB_HOST=""
DB_PORT=""
REMOTE_DB="false"

load_env() {
  if [ -f .env ]; then
    set -a
    # shellcheck disable=SC1091
    . ./.env
    set +a
    if command -v sha256sum >/dev/null 2>&1; then
      ENV_HASH=$(sha256sum .env | cut -d' ' -f1)
    else
      ENV_HASH=$(shasum -a 256 .env | cut -d' ' -f1)
    fi
  else
    # Hash the relevant vars even without an .env to detect direct exports.
    ENV_HASH=$(python3 - <<'PY'
import hashlib, os
payload = "\n".join([
    os.environ.get("DATABASE_URL_RO", ""),
    os.environ.get("VAST_SCHEMA_INCLUDE", ""),
])
print(hashlib.sha256(payload.encode()).hexdigest())
PY
)
  fi
}

parse_db_url() {
  DB_USER=""
  DB_HOST=""
  DB_PORT=""
  if [ -z "${DATABASE_URL_RO:-}" ]; then
    return
  fi
  local parsed
  parsed=$(python3 - <<'PY'
import os
from urllib import parse

url = os.environ.get("DATABASE_URL_RO")
if not url:
    print("\n\n")
else:
    parts = parse.urlsplit(url)
    print((parts.username or ""))
    print((parts.hostname or ""))
    print((parts.port or ""))
PY
)
  IFS=$'\n' read -r DB_USER DB_HOST DB_PORT <<<"$parsed"
}

# Lightweight parser used for gating Docker actions without depending on Python state.
parse_db() {
  local u="${DATABASE_URL_RO:-}"
  if [ -z "$u" ]; then
    DB_HOST=""
    DB_PORT=""
    return
  fi
  DB_HOST=$(sed -E 's#.*@([^:/?]+).*#\1#' <<<"$u")
  DB_PORT=$(sed -nE 's#.*@[^:/?]+:([0-9]+).*#\1#p' <<<"$u")
  DB_PORT=${DB_PORT:-5432}
}

is_remote_db() {
  if [ -z "${DATABASE_URL_RO:-}" ]; then
    return 1
  fi
  local host="${DB_HOST:-}"
  local port="${DB_PORT:-}"
  if [ -z "$host" ]; then
    return 1
  fi
  host=$(printf '%s' "$host" | tr '[:upper:]' '[:lower:]')
  if [ "$host" = "localhost" ] || [ "$host" = "127.0.0.1" ] || [ "$host" = "::1" ]; then
    return 1
  fi
  if [ -z "$port" ]; then
    port="5432"
  fi
  if [ "$port" = "5433" ]; then
    return 1
  fi
  return 0
}

refresh_schema_cache() {
  local cache_dir=".vast"
  mkdir -p "$cache_dir"
  local hash_file="$cache_dir/.env_hash"
  local prev=""
  if [ -f "$hash_file" ]; then
    prev=$(cat "$hash_file")
  fi
  local current="${ENV_HASH:-}"
  if [ "$current" != "$prev" ]; then
    if [ -d "$cache_dir" ]; then
      echo "[start] Detected DATABASE_URL_RO/VAST_SCHEMA_INCLUDE change; clearing schema cache (.vast)."
      rm -rf "$cache_dir"
      mkdir -p "$cache_dir"
    fi
    echo "$current" > "$hash_file"
  fi
}

print_target_banner() {
  if [ -z "${DATABASE_URL_RO:-}" ]; then
    echo "[start] Connected target: (not configured)"
    return
  fi
  local banner
  banner=$(echo "$DATABASE_URL_RO" | sed -E 's,postgresql://([^:@]+)(:[^@]*)?@([^/:]+)(:([0-9]+))?.*,user=\1 host=\3 port=\5,')
  if [[ "$banner" == *"port=" ]]; then
    local port="${DB_PORT:-}"
    if [ -z "$port" ]; then
      port="5432"
    fi
    banner="${banner}${port}"
  fi
  echo "[start] Connected target: $banner"
}

dns_check() {
  if ! is_remote_db; then
    return
  fi
  if [ -z "${DATABASE_URL_RO:-}" ]; then
    return
  fi
  if ! python3 - <<'PY'
import os
import socket
from urllib import parse

url = os.environ.get("DATABASE_URL_RO")
if not url:
    raise SystemExit(0)
host = parse.urlsplit(url).hostname
if not host:
    raise SystemExit(0)
try:
    socket.getaddrinfo(host, None)
except socket.gaierror as exc:
    print(f"[start] ERROR: Unable to resolve DATABASE_URL_RO host '{host}': {exc}")
    raise SystemExit(1)
PY
  then
    echo "[start] HINT: Verify Supabase DNS/network configuration and retry."
    exit 1
  fi
}

echo "[start] Project: $PROJECT_DIR"

load_env
parse_db_url

if [ ! -f .env ]; then
  echo "[start] WARNING: .env not found. Create one or copy from .env.example"
fi

if is_remote_db; then
  REMOTE_DB="true"
fi

print_target_banner
refresh_schema_cache
dns_check

ensure_docker() {
  if docker info >/dev/null 2>&1; then
    return 0
  fi
  # Try to start Docker Desktop on macOS
  if command -v open >/dev/null 2>&1; then
    echo "[start] Starting Docker Desktop..."
    open -g -a Docker || true
  fi
  echo -n "[start] Waiting for Docker daemon";
  for i in $(seq 1 60); do
    if docker info >/dev/null 2>&1; then echo " ready"; return 0; fi
    echo -n "."; sleep 2
  done
  echo
  echo "[start] ERROR: Docker daemon not available. Please start Docker Desktop."
  exit 1
}

ensure_container() {
  local name="vast-pg"
  local exists
  exists=$(docker ps -a --format '{{.Names}}' | grep -w "$name" || true)
  if [ -n "$exists" ]; then
    # If not running, start it
    local running
    running=$(docker ps --format '{{.Names}}' | grep -w "$name" || true)
    if [ -z "$running" ]; then
      echo "[start] Starting existing container $name..."
      docker start "$name" >/dev/null
    else
      echo "[start] Container $name already running."
    fi
  else
    echo "[start] Creating postgres:16 container $name (port 5433 -> 5432) with Pagila seed..."
    docker run --name "$name" \
      -e POSTGRES_USER=vast_ro \
      -e POSTGRES_PASSWORD=vast_ro_pwd \
      -e POSTGRES_DB=pagila \
      -p 5433:5432 \
      -v "$PWD/pagila-schema.sql":/docker-entrypoint-initdb.d/01-schema.sql \
      -v "$PWD/pagila-data.sql":/docker-entrypoint-initdb.d/02-data.sql \
      -d postgres:16 >/dev/null
  fi

  echo -n "[start] Waiting for Postgres (pagila) to become ready";
  for i in $(seq 1 90); do
    if docker exec "$name" pg_isready -U vast_ro -d pagila >/dev/null 2>&1; then
      echo " ready"; return 0; fi
    echo -n "."; sleep 2
  done
  echo
  echo "[start] ERROR: Postgres did not become ready in time. Check container logs: docker logs $name"
  exit 1
}

ensure_venv() {
  if [ ! -d .venv ]; then
    echo "[start] Creating virtualenv (.venv)..."
    python3 -m venv .venv
  fi
  # shellcheck disable=SC1091
  source .venv/bin/activate
  python -m pip install -U pip setuptools wheel >/dev/null
  local hash_file=".venv/.vast-req.hash"
  local req_hash=""
  if [ -f requirements.txt ]; then
    req_hash=$(python3 - <<'PY'
import hashlib, sys
from pathlib import Path
path = Path('requirements.txt')
print(hashlib.sha256(path.read_bytes()).hexdigest())
PY
)
  fi

  local installed_hash=""
  if [ -f "$hash_file" ]; then
    installed_hash=$(cat "$hash_file")
  fi

  if [ -n "$req_hash" ]; then
    if [ "$req_hash" != "$installed_hash" ]; then
      echo "[start] Installing dependencies (requirements changed)..."
      pip install -r requirements.txt >/dev/null
      echo "$req_hash" > "$hash_file"
    else
      echo "[start] Dependencies already satisfied (requirements unchanged)."
    fi
  fi
}

print_receipt() {
  echo ""
  echo "[start] âœ… Environment ready"
  if [ "$REMOTE_DB" = "true" ]; then
    local port="${DB_PORT:-}"
    if [ -z "$port" ]; then
      port="5432"
    fi
    echo "- Database: remote ${DB_HOST:-unknown}:${port}"
    echo "- Docker: skipped (remote target)"
  else
    echo "- Docker: $(docker version --format '{{.Server.Version}}' 2>/dev/null || echo 'unknown')"
    echo "- Container: vast-pg (port 5433 -> 5432)"
  fi
  echo "- Python: $(python -V 2>&1)"
  echo "- VAST entry: start_vast.py"
  echo ""
}

parse_db
if [[ -n "${DATABASE_URL_RO:-}" && "$DB_HOST" != "localhost" && "$DB_HOST" != "127.0.0.1" && "$DB_HOST" != "::1" && "$DB_PORT" != "5433" ]]; then
  REMOTE_DB="true"
  echo "[start] Remote DB detected; skipping Pagila container."
else
  ensure_docker
  ensure_container
fi
ensure_venv
print_receipt

ensure_node() {
  if ! command -v npm >/dev/null 2>&1; then
    echo "[start] ERROR: npm is not installed. Please install Node.js (https://nodejs.org)"
    exit 1
  fi
}

ensure_electron_deps() {
  if [ ! -d "desktop/electron/node_modules" ]; then
    echo "[start] Installing Electron dependencies (desktop/electron)..."
    if ! npm --prefix desktop/electron ci >/dev/null 2>&1; then
      echo "[start] Falling back to npm install..."
      npm --prefix desktop/electron install >/dev/null
    fi
  fi
}

start_api() {
  local host="127.0.0.1"
  local port="${API_PORT:-8000}"
  echo "[start] Starting API on http://${host}:${port} ..."
  # Use uvicorn inside venv
  uvicorn src.vast.api:app --host "$host" --port "$port" --reload &
  API_PID=$!
}

wait_for_api() {
  local host="127.0.0.1"
  local port="${API_PORT:-8000}"
  echo -n "[start] Waiting for API healthcheck";
  for i in $(seq 1 60); do
    if curl -sSf "http://${host}:${port}/health" >/dev/null 2>&1; then echo " ready"; return 0; fi
    echo -n "."; sleep 1
  done
  echo
  echo "[start] ERROR: API did not become ready on ${host}:${port}"
  exit 1
}

start_electron() {
  echo "[start] Launching Electron app..."
  npm --prefix desktop/electron start &
  ELECTRON_PID=$!
}

cleanup() {
  local code=$?
  echo "\n[start] Shutting down..."
  if [ -n "${ELECTRON_PID:-}" ] && ps -p "$ELECTRON_PID" >/dev/null 2>&1; then
    kill "$ELECTRON_PID" >/dev/null 2>&1 || true
    wait "$ELECTRON_PID" 2>/dev/null || true
  fi
  if [ -n "${API_PID:-}" ] && ps -p "$API_PID" >/dev/null 2>&1; then
    kill "$API_PID" >/dev/null 2>&1 || true
    wait "$API_PID" 2>/dev/null || true
  fi
  exit $code
}

trap cleanup TERM EXIT

echo "[start] Launching VAST stack (API + Electron + CLI). Use 'exit' in CLI to quit."

ensure_node
ensure_electron_deps
start_api
wait_for_api
start_electron

# Run CLI in the foreground. When it exits, cleanup trap will run.
echo "[start] Launching CLI..."
python start_vast.py
